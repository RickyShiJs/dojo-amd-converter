define([], function () {
	var util;
	return util = {
		computeNamespace: function (expression) {
			//	summary:
			//		compute the full namespace
			function computeName(expression) {
				//	summary:
				//		Reduces a MemberExpression into a flat list of identifiers.
				//	returns: Array
				//		List of Identifier or Literal nodes. If an Identifier has a computed property,
				//		this means that the MemberExpression was created using an array notation.

				var name = [];
				if (expression.type === "Identifier") {
					name.push(expression.name);
				}
				if (expression.object) {
					if (expression.object.type === "MemberExpression") {
						name.push.apply(name, computeName(expression.object));
					}
					else {
						name.push(expression.object);
					}
				}

				if (expression.computed && expression.property.type === "Identifier") {
					name.push(Object.create(expression.property, {
						computed: {
							value: true,
							writable: true,
							enumerable: true,
							configurable: true
						}
					}));
				}
				else if (expression.property) {
					name.push(expression.property);
				}

				return name;
			}
			return computeName(expression).map(function (identifier) {
					if (!identifier) {
						return "";
					}
					if (identifier.computed && identifier.type !== "Literal") {
						return "#computed#";
					}

					return identifier.value || identifier.name;
				}).join(".");

		},
		is: function (expectedName, contains) {
			//	summary:
			//		Creates a function to determine whether or not a given MemberExpression matches the expected name.
			return function (callInfo) {
				var computed = util.computeNamespace(callInfo);

				if (!computed) {
					return false;
				}

				return contains ?
					computed.slice(0, expectedName.length) === expectedName :
					expectedName === computed;
			};
		},

		isCall: function (expectedAccessor, contains) {
			//	summary:
			//		Creates a function to determine whether or not the given CallExpression matches the expected name.

			var isName = util.is(expectedAccessor, contains);
			return function (callInfo) {
				return callInfo.type === "CallExpression" && isName(callInfo.callee);
			};
		},

		toMid: function (name) {
			//	summary:
			//		Converts a JavaScript name to an AMD module ID.

			return name.replace(/\./g, "/");
		},

		traverse: function (object, visitor, master) {
			//	summary:
			//		Traverses a tree of objects.

			var key, child, parent, path;

			parent = typeof master === "undefined" ? [] : master;

			if (visitor(object, parent) === false) {
				return;
			}

			for (key in object) {
				if (object.hasOwnProperty(key) && key !== "parent") {
					child = object[key];
					path = [ object ];
					path.push(parent);
					if (typeof child === "object" && child !== null) {
						child.parent = object;
						util.traverse(child, visitor, path);
					}
				}
			}
		},

		traverseDom: function (node, visitor) {
			//	summary:
			//		Traverses a DOM generated by libxml.

			if (visitor(node) === false) {
				return;
			}

			var children = node.childNodes();

			for (var i = 0, child; (child = children[i]); ++i) {
				util.traverseDom(child, visitor);
			}
		}
	};
});